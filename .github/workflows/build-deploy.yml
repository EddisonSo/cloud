name: Build and Deploy

on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      force_all:
        description: 'Force rebuild all services'
        type: boolean
        default: false

env:
  NS: core
  # Image names
  SFS_IMAGE: docker.io/eddisonso/ecloud-sfs
  LOGGING_IMAGE: docker.io/eddisonso/ecloud-logging
  COMPUTE_IMAGE: docker.io/eddisonso/ecloud-compute
  COMPUTE_BASE_IMAGE: docker.io/eddisonso/ecloud-compute-base
  FRONTEND_IMAGE: docker.io/eddisonso/ecloud-frontend
  AUTH_IMAGE: docker.io/eddisonso/ecloud-auth
  GATEWAY_IMAGE: docker.io/eddisonso/ecloud-gateway
  DOCS_IMAGE: docker.io/eddisonso/ecloud-docs
  GFS_IMAGE: docker.io/eddisonso/ecloud-gfs
  CLUSTER_MONITOR_IMAGE: docker.io/eddisonso/cluster-monitor
  NOTIFICATIONS_IMAGE: docker.io/eddisonso/ecloud-notifications
  ALERTING_IMAGE: docker.io/eddisonso/alerting-service

jobs:
  # Detect which services have changes
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      sfs: ${{ steps.filter.outputs.sfs }}
      logging: ${{ steps.filter.outputs.logging }}
      compute: ${{ steps.filter.outputs.compute }}
      compute-base: ${{ steps.filter.outputs.compute-base }}
      frontend: ${{ steps.filter.outputs.frontend }}
      auth: ${{ steps.filter.outputs.auth }}
      gateway: ${{ steps.filter.outputs.gateway }}
      docs: ${{ steps.filter.outputs.docs }}
      gfs: ${{ steps.filter.outputs.gfs }}
      go-gfs: ${{ steps.filter.outputs.go-gfs }}
      cluster-monitor: ${{ steps.filter.outputs.cluster-monitor }}
      notifications: ${{ steps.filter.outputs.notifications }}
      alerting: ${{ steps.filter.outputs.alerting }}
      any_service: ${{ steps.filter.outputs.any_service }}
      image_tag: ${{ steps.tag.outputs.image_tag }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 2
      - name: Generate image tag
        id: tag
        run: echo "image_tag=$(date -u +%Y%m%d-%H%M%S)" >> $GITHUB_OUTPUT
      - uses: dorny/paths-filter@v3
        id: filter
        with:
          filters: |
            go-gfs:
              - 'go-gfs/**'
            sfs:
              - 'edd-cloud-interface/services/sfs/**'
              - 'go-gfs/**'
            logging:
              - 'log-service/**'
              - 'go-gfs/**'
              - 'proto/**'
            compute:
              - 'edd-cloud-interface/services/compute/**'
              - 'go-gfs/**'
            compute-base:
              - 'edd-cloud-interface/services/compute/images/base/**'
            frontend:
              - 'edd-cloud-interface/frontend/**'
            auth:
              - 'edd-cloud-auth/**'
            gateway:
              - 'edd-gateway/**'
              - 'go-gfs/**'
            docs:
              - 'edd-cloud-docs/**'
            gfs:
              - 'go-gfs/**'
            cluster-monitor:
              - 'cluster-monitor/**'
              - 'go-gfs/**'
              - 'proto/**'
            notifications:
              - 'notification-service/**'
              - 'proto/notification/**'
            alerting:
              - 'alerting-service/**'
              - 'go-gfs/**'
              - 'proto/**'
            any_service:
              - 'edd-cloud-interface/**'
              - 'edd-cloud-auth/**'
              - 'edd-gateway/**'
              - 'edd-cloud-docs/**'
              - 'go-gfs/**'
              - 'cluster-monitor/**'
              - 'notification-service/**'
              - 'alerting-service/**'
              - 'log-service/**'

  # Build SFS service
  build-sfs:
    needs: detect-changes
    if: needs.detect-changes.outputs.sfs == 'true' || github.event.inputs.force_all == 'true'
    env:
      IMAGE_TAG: ${{ needs.detect-changes.outputs.image_tag }}
    strategy:
      matrix:
        include:
          - runner: ubuntu-24.04-arm
            platform: linux/arm64
            suffix: arm64
          - runner: ubuntu-latest
            platform: linux/amd64
            suffix: amd64
    runs-on: ${{ matrix.runner }}
    steps:
      - uses: actions/checkout@v4
      - uses: docker/setup-buildx-action@v3
      - uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}
      - name: Install proto tooling
        run: |
          sudo apt-get update && sudo apt-get install -y protobuf-compiler
          go install google.golang.org/protobuf/cmd/protoc-gen-go@latest
          go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest
          echo "$HOME/go/bin" >> $GITHUB_PATH
      - name: Generate go-gfs protobufs
        working-directory: go-gfs
        run: make proto
      - name: Build & push
        run: |
          docker buildx build \
            --platform ${{ matrix.platform }} \
            -f edd-cloud-interface/services/sfs/Dockerfile \
            -t ${SFS_IMAGE}:${IMAGE_TAG}-${{ matrix.suffix }} \
            --provenance=false --sbom=false --push .

  # Build Logging service
  build-logging:
    needs: detect-changes
    if: needs.detect-changes.outputs.logging == 'true' || github.event.inputs.force_all == 'true'
    env:
      IMAGE_TAG: ${{ needs.detect-changes.outputs.image_tag }}
    strategy:
      matrix:
        include:
          - runner: ubuntu-24.04-arm
            platform: linux/arm64
            suffix: arm64
          - runner: ubuntu-latest
            platform: linux/amd64
            suffix: amd64
    runs-on: ${{ matrix.runner }}
    steps:
      - uses: actions/checkout@v4
      - uses: docker/setup-buildx-action@v3
      - uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}
      - name: Install proto tooling
        run: |
          sudo apt-get update && sudo apt-get install -y protobuf-compiler
          go install google.golang.org/protobuf/cmd/protoc-gen-go@latest
          go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest
          echo "$HOME/go/bin" >> $GITHUB_PATH
      - name: Generate go-gfs protobufs
        working-directory: go-gfs
        run: make proto
      - name: Build & push
        run: |
          docker buildx build \
            --platform ${{ matrix.platform }} \
            -f log-service/Dockerfile \
            -t ${LOGGING_IMAGE}:${IMAGE_TAG}-${{ matrix.suffix }} \
            --provenance=false --sbom=false --push .

  # Build Compute service
  build-compute:
    needs: detect-changes
    if: needs.detect-changes.outputs.compute == 'true' || github.event.inputs.force_all == 'true'
    env:
      IMAGE_TAG: ${{ needs.detect-changes.outputs.image_tag }}
    strategy:
      matrix:
        include:
          - runner: ubuntu-24.04-arm
            platform: linux/arm64
            suffix: arm64
          - runner: ubuntu-latest
            platform: linux/amd64
            suffix: amd64
    runs-on: ${{ matrix.runner }}
    steps:
      - uses: actions/checkout@v4
      - uses: docker/setup-buildx-action@v3
      - uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}
      - name: Install proto tooling
        run: |
          sudo apt-get update && sudo apt-get install -y protobuf-compiler
          go install google.golang.org/protobuf/cmd/protoc-gen-go@latest
          go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest
          echo "$HOME/go/bin" >> $GITHUB_PATH
      - name: Generate go-gfs protobufs
        working-directory: go-gfs
        run: make proto
      - name: Build & push
        run: |
          docker buildx build \
            --platform ${{ matrix.platform }} \
            -f edd-cloud-interface/services/compute/Dockerfile \
            -t ${COMPUTE_IMAGE}:${IMAGE_TAG}-${{ matrix.suffix }} \
            --provenance=false --sbom=false --push .

  # Build Compute Base image
  build-compute-base:
    needs: detect-changes
    if: needs.detect-changes.outputs.compute-base == 'true' || github.event.inputs.force_all == 'true'
    env:
      IMAGE_TAG: ${{ needs.detect-changes.outputs.image_tag }}
    strategy:
      matrix:
        include:
          - runner: ubuntu-24.04-arm
            platform: linux/arm64
            suffix: arm64
          - runner: ubuntu-latest
            platform: linux/amd64
            suffix: amd64
    runs-on: ${{ matrix.runner }}
    steps:
      - uses: actions/checkout@v4
      - uses: docker/setup-buildx-action@v3
      - uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}
      - name: Build & push
        run: |
          docker buildx build \
            --platform ${{ matrix.platform }} \
            -f edd-cloud-interface/services/compute/images/base/Dockerfile \
            -t ${COMPUTE_BASE_IMAGE}:${IMAGE_TAG}-${{ matrix.suffix }} \
            --provenance=false --sbom=false --push edd-cloud-interface/services/compute/images/base

  # Build Frontend
  build-frontend:
    needs: detect-changes
    if: needs.detect-changes.outputs.frontend == 'true' || github.event.inputs.force_all == 'true'
    env:
      IMAGE_TAG: ${{ needs.detect-changes.outputs.image_tag }}
    strategy:
      matrix:
        include:
          - runner: ubuntu-24.04-arm
            platform: linux/arm64
            suffix: arm64
          - runner: ubuntu-latest
            platform: linux/amd64
            suffix: amd64
    runs-on: ${{ matrix.runner }}
    steps:
      - uses: actions/checkout@v4
      - name: Get commit time
        id: commit-time
        run: echo "time=$(git log -1 --format='%ci' | cut -d' ' -f1,2)" >> $GITHUB_OUTPUT
      - uses: docker/setup-buildx-action@v3
      - uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}
      - name: Build & push
        run: |
          docker buildx build \
            --platform ${{ matrix.platform }} \
            -f edd-cloud-interface/frontend/Dockerfile \
            --build-arg BUILD_COMMIT=${GITHUB_SHA::7} \
            --build-arg BUILD_TIME="${{ steps.commit-time.outputs.time }}" \
            -t ${FRONTEND_IMAGE}:${IMAGE_TAG}-${{ matrix.suffix }} \
            --provenance=false --sbom=false --push edd-cloud-interface/frontend

  # Build Auth service
  build-auth:
    needs: detect-changes
    if: needs.detect-changes.outputs.auth == 'true' || github.event.inputs.force_all == 'true'
    env:
      IMAGE_TAG: ${{ needs.detect-changes.outputs.image_tag }}
    strategy:
      matrix:
        include:
          - runner: ubuntu-24.04-arm
            platform: linux/arm64
            suffix: arm64
          - runner: ubuntu-latest
            platform: linux/amd64
            suffix: amd64
    runs-on: ${{ matrix.runner }}
    steps:
      - uses: actions/checkout@v4
      - uses: docker/setup-buildx-action@v3
      - uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}
      - name: Build & push
        run: |
          docker buildx build \
            --platform ${{ matrix.platform }} \
            -f edd-cloud-auth/Dockerfile \
            -t ${AUTH_IMAGE}:${IMAGE_TAG}-${{ matrix.suffix }} \
            --provenance=false --sbom=false --push .

  # Build Gateway service
  build-gateway:
    needs: detect-changes
    if: needs.detect-changes.outputs.gateway == 'true' || github.event.inputs.force_all == 'true'
    env:
      IMAGE_TAG: ${{ needs.detect-changes.outputs.image_tag }}
    strategy:
      matrix:
        include:
          - runner: ubuntu-24.04-arm
            platform: linux/arm64
            suffix: arm64
          - runner: ubuntu-latest
            platform: linux/amd64
            suffix: amd64
    runs-on: ${{ matrix.runner }}
    steps:
      - uses: actions/checkout@v4
      - uses: docker/setup-buildx-action@v3
      - uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}
      - name: Install proto tooling
        run: |
          sudo apt-get update && sudo apt-get install -y protobuf-compiler
          go install google.golang.org/protobuf/cmd/protoc-gen-go@latest
          go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest
          echo "$HOME/go/bin" >> $GITHUB_PATH
      - name: Generate go-gfs protobufs
        working-directory: go-gfs
        run: make proto
      - name: Build & push
        run: |
          docker buildx build \
            --platform ${{ matrix.platform }} \
            -f edd-gateway/Dockerfile \
            -t ${GATEWAY_IMAGE}:${IMAGE_TAG}-${{ matrix.suffix }} \
            --provenance=false --sbom=false --push .

  # Build Docs
  build-docs:
    needs: detect-changes
    if: needs.detect-changes.outputs.docs == 'true' || github.event.inputs.force_all == 'true'
    env:
      IMAGE_TAG: ${{ needs.detect-changes.outputs.image_tag }}
    strategy:
      matrix:
        include:
          - runner: ubuntu-24.04-arm
            platform: linux/arm64
            suffix: arm64
          - runner: ubuntu-latest
            platform: linux/amd64
            suffix: amd64
    runs-on: ${{ matrix.runner }}
    steps:
      - uses: actions/checkout@v4
      - uses: docker/setup-buildx-action@v3
      - uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}
      - name: Build & push
        run: |
          docker buildx build \
            --platform ${{ matrix.platform }} \
            -f edd-cloud-docs/Dockerfile \
            -t ${DOCS_IMAGE}:${IMAGE_TAG}-${{ matrix.suffix }} \
            --provenance=false --sbom=false --push edd-cloud-docs

  # Build Cluster Monitor
  build-cluster-monitor:
    needs: detect-changes
    if: needs.detect-changes.outputs.cluster-monitor == 'true' || github.event.inputs.force_all == 'true'
    env:
      IMAGE_TAG: ${{ needs.detect-changes.outputs.image_tag }}
    strategy:
      matrix:
        include:
          - runner: ubuntu-24.04-arm
            platform: linux/arm64
            suffix: arm64
          - runner: ubuntu-latest
            platform: linux/amd64
            suffix: amd64
    runs-on: ${{ matrix.runner }}
    steps:
      - uses: actions/checkout@v4
      - uses: docker/setup-buildx-action@v3
      - uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}
      - name: Build & push
        run: |
          docker buildx build \
            --platform ${{ matrix.platform }} \
            -f cluster-monitor/Dockerfile \
            -t ${CLUSTER_MONITOR_IMAGE}:${IMAGE_TAG}-${{ matrix.suffix }} \
            --provenance=false --sbom=false --push .

  # Build GFS (chunkserver + master)
  build-gfs:
    needs: detect-changes
    if: needs.detect-changes.outputs.gfs == 'true' || github.event.inputs.force_all == 'true'
    env:
      IMAGE_TAG: ${{ needs.detect-changes.outputs.image_tag }}
    strategy:
      matrix:
        include:
          - runner: ubuntu-24.04-arm
            platform: linux/arm64
            suffix: arm64
          - runner: ubuntu-latest
            platform: linux/amd64
            suffix: amd64
    runs-on: ${{ matrix.runner }}
    steps:
      - uses: actions/checkout@v4
      - uses: docker/setup-buildx-action@v3
      - uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}
      - name: Build & push
        run: |
          docker buildx build \
            --platform ${{ matrix.platform }} \
            -f go-gfs/Dockerfile \
            -t ${GFS_IMAGE}:${IMAGE_TAG}-${{ matrix.suffix }} \
            --provenance=false --sbom=false --push go-gfs

  # Build Notifications service
  build-notifications:
    needs: detect-changes
    if: needs.detect-changes.outputs.notifications == 'true' || github.event.inputs.force_all == 'true'
    env:
      IMAGE_TAG: ${{ needs.detect-changes.outputs.image_tag }}
    strategy:
      matrix:
        include:
          - runner: ubuntu-24.04-arm
            platform: linux/arm64
            suffix: arm64
          - runner: ubuntu-latest
            platform: linux/amd64
            suffix: amd64
    runs-on: ${{ matrix.runner }}
    steps:
      - uses: actions/checkout@v4
      - uses: docker/setup-buildx-action@v3
      - uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}
      - name: Build & push
        run: |
          docker buildx build \
            --platform ${{ matrix.platform }} \
            -f notification-service/Dockerfile \
            -t ${NOTIFICATIONS_IMAGE}:${IMAGE_TAG}-${{ matrix.suffix }} \
            --provenance=false --sbom=false --push .

  # Build Alerting service
  build-alerting:
    needs: detect-changes
    if: needs.detect-changes.outputs.alerting == 'true' || github.event.inputs.force_all == 'true'
    env:
      IMAGE_TAG: ${{ needs.detect-changes.outputs.image_tag }}
    strategy:
      matrix:
        include:
          - runner: ubuntu-24.04-arm
            platform: linux/arm64
            suffix: arm64
          - runner: ubuntu-latest
            platform: linux/amd64
            suffix: amd64
    runs-on: ${{ matrix.runner }}
    steps:
      - uses: actions/checkout@v4
      - uses: docker/setup-buildx-action@v3
      - uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}
      - name: Build & push
        run: |
          docker buildx build \
            --platform ${{ matrix.platform }} \
            -f alerting-service/Dockerfile \
            -t ${ALERTING_IMAGE}:${IMAGE_TAG}-${{ matrix.suffix }} \
            --provenance=false --sbom=false --push .

  # Create manifests for built services
  create-manifests:
    needs:
      - detect-changes
      - build-sfs
      - build-logging
      - build-compute
      - build-compute-base
      - build-frontend
      - build-auth
      - build-gateway
      - build-docs
      - build-cluster-monitor
      - build-gfs
      - build-notifications
      - build-alerting
    if: always() && (needs.detect-changes.outputs.any_service == 'true' || github.event.inputs.force_all == 'true')
    runs-on: ubuntu-latest
    env:
      IMAGE_TAG: ${{ needs.detect-changes.outputs.image_tag }}
    outputs:
      sfs_built: ${{ steps.check.outputs.sfs_built }}
      logging_built: ${{ steps.check.outputs.logging_built }}
      compute_built: ${{ steps.check.outputs.compute_built }}
      compute_base_built: ${{ steps.check.outputs.compute_base_built }}
      frontend_built: ${{ steps.check.outputs.frontend_built }}
      auth_built: ${{ steps.check.outputs.auth_built }}
      gateway_built: ${{ steps.check.outputs.gateway_built }}
      docs_built: ${{ steps.check.outputs.docs_built }}
      cluster_monitor_built: ${{ steps.check.outputs.cluster_monitor_built }}
      gfs_built: ${{ steps.check.outputs.gfs_built }}
      notifications_built: ${{ steps.check.outputs.notifications_built }}
      alerting_built: ${{ steps.check.outputs.alerting_built }}
      image_tag: ${{ needs.detect-changes.outputs.image_tag }}
    steps:
      - uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}
      - name: Check which builds succeeded
        id: check
        run: |
          echo "sfs_built=${{ needs.build-sfs.result == 'success' }}" >> $GITHUB_OUTPUT
          echo "logging_built=${{ needs.build-logging.result == 'success' }}" >> $GITHUB_OUTPUT
          echo "compute_built=${{ needs.build-compute.result == 'success' }}" >> $GITHUB_OUTPUT
          echo "compute_base_built=${{ needs.build-compute-base.result == 'success' }}" >> $GITHUB_OUTPUT
          echo "frontend_built=${{ needs.build-frontend.result == 'success' }}" >> $GITHUB_OUTPUT
          echo "auth_built=${{ needs.build-auth.result == 'success' }}" >> $GITHUB_OUTPUT
          echo "gateway_built=${{ needs.build-gateway.result == 'success' }}" >> $GITHUB_OUTPUT
          echo "docs_built=${{ needs.build-docs.result == 'success' }}" >> $GITHUB_OUTPUT
          echo "cluster_monitor_built=${{ needs.build-cluster-monitor.result == 'success' }}" >> $GITHUB_OUTPUT
          echo "gfs_built=${{ needs.build-gfs.result == 'success' }}" >> $GITHUB_OUTPUT
          echo "notifications_built=${{ needs.build-notifications.result == 'success' }}" >> $GITHUB_OUTPUT
          echo "alerting_built=${{ needs.build-alerting.result == 'success' }}" >> $GITHUB_OUTPUT
      - name: Create SFS manifest
        if: needs.build-sfs.result == 'success'
        run: |
          docker manifest create ${SFS_IMAGE}:${IMAGE_TAG} \
            ${SFS_IMAGE}:${IMAGE_TAG}-arm64 \
            ${SFS_IMAGE}:${IMAGE_TAG}-amd64
          docker manifest create ${SFS_IMAGE}:latest \
            ${SFS_IMAGE}:${IMAGE_TAG}-arm64 \
            ${SFS_IMAGE}:${IMAGE_TAG}-amd64
          docker manifest push ${SFS_IMAGE}:${IMAGE_TAG}
          docker manifest push ${SFS_IMAGE}:latest
      - name: Create Logging manifest
        if: needs.build-logging.result == 'success'
        run: |
          docker manifest create ${LOGGING_IMAGE}:${IMAGE_TAG} \
            ${LOGGING_IMAGE}:${IMAGE_TAG}-arm64 \
            ${LOGGING_IMAGE}:${IMAGE_TAG}-amd64
          docker manifest create ${LOGGING_IMAGE}:latest \
            ${LOGGING_IMAGE}:${IMAGE_TAG}-arm64 \
            ${LOGGING_IMAGE}:${IMAGE_TAG}-amd64
          docker manifest push ${LOGGING_IMAGE}:${IMAGE_TAG}
          docker manifest push ${LOGGING_IMAGE}:latest
      - name: Create Compute manifest
        if: needs.build-compute.result == 'success'
        run: |
          docker manifest create ${COMPUTE_IMAGE}:${IMAGE_TAG} \
            ${COMPUTE_IMAGE}:${IMAGE_TAG}-arm64 \
            ${COMPUTE_IMAGE}:${IMAGE_TAG}-amd64
          docker manifest create ${COMPUTE_IMAGE}:latest \
            ${COMPUTE_IMAGE}:${IMAGE_TAG}-arm64 \
            ${COMPUTE_IMAGE}:${IMAGE_TAG}-amd64
          docker manifest push ${COMPUTE_IMAGE}:${IMAGE_TAG}
          docker manifest push ${COMPUTE_IMAGE}:latest
      - name: Create Compute Base manifest
        if: needs.build-compute-base.result == 'success'
        run: |
          docker manifest create ${COMPUTE_BASE_IMAGE}:${IMAGE_TAG} \
            ${COMPUTE_BASE_IMAGE}:${IMAGE_TAG}-arm64 \
            ${COMPUTE_BASE_IMAGE}:${IMAGE_TAG}-amd64
          docker manifest create ${COMPUTE_BASE_IMAGE}:latest \
            ${COMPUTE_BASE_IMAGE}:${IMAGE_TAG}-arm64 \
            ${COMPUTE_BASE_IMAGE}:${IMAGE_TAG}-amd64
          docker manifest push ${COMPUTE_BASE_IMAGE}:${IMAGE_TAG}
          docker manifest push ${COMPUTE_BASE_IMAGE}:latest
      - name: Create Frontend manifest
        if: needs.build-frontend.result == 'success'
        run: |
          docker manifest create ${FRONTEND_IMAGE}:${IMAGE_TAG} \
            ${FRONTEND_IMAGE}:${IMAGE_TAG}-arm64 \
            ${FRONTEND_IMAGE}:${IMAGE_TAG}-amd64
          docker manifest create ${FRONTEND_IMAGE}:latest \
            ${FRONTEND_IMAGE}:${IMAGE_TAG}-arm64 \
            ${FRONTEND_IMAGE}:${IMAGE_TAG}-amd64
          docker manifest push ${FRONTEND_IMAGE}:${IMAGE_TAG}
          docker manifest push ${FRONTEND_IMAGE}:latest
      - name: Create Auth manifest
        if: needs.build-auth.result == 'success'
        run: |
          docker manifest create ${AUTH_IMAGE}:${IMAGE_TAG} \
            ${AUTH_IMAGE}:${IMAGE_TAG}-arm64 \
            ${AUTH_IMAGE}:${IMAGE_TAG}-amd64
          docker manifest create ${AUTH_IMAGE}:latest \
            ${AUTH_IMAGE}:${IMAGE_TAG}-arm64 \
            ${AUTH_IMAGE}:${IMAGE_TAG}-amd64
          docker manifest push ${AUTH_IMAGE}:${IMAGE_TAG}
          docker manifest push ${AUTH_IMAGE}:latest
      - name: Create Gateway manifest
        if: needs.build-gateway.result == 'success'
        run: |
          docker manifest create ${GATEWAY_IMAGE}:${IMAGE_TAG} \
            ${GATEWAY_IMAGE}:${IMAGE_TAG}-arm64 \
            ${GATEWAY_IMAGE}:${IMAGE_TAG}-amd64
          docker manifest create ${GATEWAY_IMAGE}:latest \
            ${GATEWAY_IMAGE}:${IMAGE_TAG}-arm64 \
            ${GATEWAY_IMAGE}:${IMAGE_TAG}-amd64
          docker manifest push ${GATEWAY_IMAGE}:${IMAGE_TAG}
          docker manifest push ${GATEWAY_IMAGE}:latest
      - name: Create Docs manifest
        if: needs.build-docs.result == 'success'
        run: |
          docker manifest create ${DOCS_IMAGE}:${IMAGE_TAG} \
            ${DOCS_IMAGE}:${IMAGE_TAG}-arm64 \
            ${DOCS_IMAGE}:${IMAGE_TAG}-amd64
          docker manifest create ${DOCS_IMAGE}:latest \
            ${DOCS_IMAGE}:${IMAGE_TAG}-arm64 \
            ${DOCS_IMAGE}:${IMAGE_TAG}-amd64
          docker manifest push ${DOCS_IMAGE}:${IMAGE_TAG}
          docker manifest push ${DOCS_IMAGE}:latest
      - name: Create Cluster Monitor manifest
        if: needs.build-cluster-monitor.result == 'success'
        run: |
          docker manifest create ${CLUSTER_MONITOR_IMAGE}:${IMAGE_TAG} \
            ${CLUSTER_MONITOR_IMAGE}:${IMAGE_TAG}-arm64 \
            ${CLUSTER_MONITOR_IMAGE}:${IMAGE_TAG}-amd64
          docker manifest create ${CLUSTER_MONITOR_IMAGE}:latest \
            ${CLUSTER_MONITOR_IMAGE}:${IMAGE_TAG}-arm64 \
            ${CLUSTER_MONITOR_IMAGE}:${IMAGE_TAG}-amd64
          docker manifest push ${CLUSTER_MONITOR_IMAGE}:${IMAGE_TAG}
          docker manifest push ${CLUSTER_MONITOR_IMAGE}:latest
      - name: Create GFS manifest
        if: needs.build-gfs.result == 'success'
        run: |
          docker manifest create ${GFS_IMAGE}:${IMAGE_TAG} \
            ${GFS_IMAGE}:${IMAGE_TAG}-arm64 \
            ${GFS_IMAGE}:${IMAGE_TAG}-amd64
          docker manifest create ${GFS_IMAGE}:latest \
            ${GFS_IMAGE}:${IMAGE_TAG}-arm64 \
            ${GFS_IMAGE}:${IMAGE_TAG}-amd64
          docker manifest push ${GFS_IMAGE}:${IMAGE_TAG}
          docker manifest push ${GFS_IMAGE}:latest
      - name: Create Notifications manifest
        if: needs.build-notifications.result == 'success'
        run: |
          docker manifest create ${NOTIFICATIONS_IMAGE}:${IMAGE_TAG} \
            ${NOTIFICATIONS_IMAGE}:${IMAGE_TAG}-arm64 \
            ${NOTIFICATIONS_IMAGE}:${IMAGE_TAG}-amd64
          docker manifest create ${NOTIFICATIONS_IMAGE}:latest \
            ${NOTIFICATIONS_IMAGE}:${IMAGE_TAG}-arm64 \
            ${NOTIFICATIONS_IMAGE}:${IMAGE_TAG}-amd64
          docker manifest push ${NOTIFICATIONS_IMAGE}:${IMAGE_TAG}
          docker manifest push ${NOTIFICATIONS_IMAGE}:latest
      - name: Create Alerting manifest
        if: needs.build-alerting.result == 'success'
        run: |
          docker manifest create ${ALERTING_IMAGE}:${IMAGE_TAG} \
            ${ALERTING_IMAGE}:${IMAGE_TAG}-arm64 \
            ${ALERTING_IMAGE}:${IMAGE_TAG}-amd64
          docker manifest create ${ALERTING_IMAGE}:latest \
            ${ALERTING_IMAGE}:${IMAGE_TAG}-arm64 \
            ${ALERTING_IMAGE}:${IMAGE_TAG}-amd64
          docker manifest push ${ALERTING_IMAGE}:${IMAGE_TAG}
          docker manifest push ${ALERTING_IMAGE}:latest

  # Deploy only the services that were built
  deploy:
    needs: create-manifests
    if: always() && needs.create-manifests.result == 'success'
    runs-on: ubuntu-latest
    env:
      IMAGE_TAG: ${{ needs.create-manifests.outputs.image_tag }}
    steps:
      - name: Configure kubectl
        env:
          GFS_CI_KUBECONFIG_B64: ${{ secrets.GFS_CI_KUBECONFIG_B64 }}
        run: |
          mkdir -p ~/.kube
          echo "$GFS_CI_KUBECONFIG_B64" | base64 -d > ~/.kube/config
          chmod 600 ~/.kube/config
      - name: Deploy SFS
        if: needs.create-manifests.outputs.sfs_built == 'true'
        run: kubectl -n $NS set image deployment/simple-file-share-backend backend=${SFS_IMAGE}:${IMAGE_TAG}
      - name: Deploy Logging
        if: needs.create-manifests.outputs.logging_built == 'true'
        run: kubectl -n $NS set image deployment/log-service log-service=${LOGGING_IMAGE}:${IMAGE_TAG}
      - name: Deploy Compute
        if: needs.create-manifests.outputs.compute_built == 'true'
        run: kubectl -n $NS set image deployment/edd-compute edd-compute=${COMPUTE_IMAGE}:${IMAGE_TAG}
      - name: Deploy Frontend
        if: needs.create-manifests.outputs.frontend_built == 'true'
        run: kubectl -n $NS set image deployment/simple-file-share-frontend frontend=${FRONTEND_IMAGE}:${IMAGE_TAG}
      - name: Deploy Auth
        if: needs.create-manifests.outputs.auth_built == 'true'
        run: kubectl -n $NS set image deployment/auth-service auth-service=${AUTH_IMAGE}:${IMAGE_TAG}
      - name: Deploy Gateway
        if: needs.create-manifests.outputs.gateway_built == 'true'
        run: kubectl -n $NS set image deployment/gateway gateway=${GATEWAY_IMAGE}:${IMAGE_TAG}
      - name: Deploy Docs
        if: needs.create-manifests.outputs.docs_built == 'true'
        run: kubectl -n $NS set image deployment/edd-cloud-docs docs=${DOCS_IMAGE}:${IMAGE_TAG}
      - name: Deploy Cluster Monitor
        if: needs.create-manifests.outputs.cluster_monitor_built == 'true'
        run: kubectl -n $NS set image deployment/cluster-monitor cluster-monitor=${CLUSTER_MONITOR_IMAGE}:${IMAGE_TAG}
      - name: Deploy GFS Master
        if: needs.create-manifests.outputs.gfs_built == 'true'
        run: kubectl -n $NS set image deployment/gfs-master master=${GFS_IMAGE}:${IMAGE_TAG}
      - name: Deploy GFS Chunkserver
        if: needs.create-manifests.outputs.gfs_built == 'true'
        run: kubectl -n $NS set image daemonset/gfs-chunkserver chunkserver=${GFS_IMAGE}:${IMAGE_TAG}
      - name: Deploy Notifications
        if: needs.create-manifests.outputs.notifications_built == 'true'
        run: kubectl -n $NS set image deployment/notification-service notification-service=${NOTIFICATIONS_IMAGE}:${IMAGE_TAG}
      - name: Deploy Alerting
        if: needs.create-manifests.outputs.alerting_built == 'true'
        run: kubectl -n $NS set image deployment/alerting-service alerting-service=${ALERTING_IMAGE}:${IMAGE_TAG}
